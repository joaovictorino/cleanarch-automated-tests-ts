"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MutantModel_coveredByTests, _MutantModel_killedByTests;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutantModel = void 0;
function assertSourceFileDefined(sourceFile) {
    if (sourceFile === undefined) {
        throw new Error('mutant.sourceFile was not defined');
    }
}
/**
 * Represent a model of a mutant that contains its test relationship
 */
class MutantModel {
    constructor(input) {
        _MutantModel_coveredByTests.set(this, new Map());
        _MutantModel_killedByTests.set(this, new Map());
        this.coveredBy = input.coveredBy;
        this.description = input.description;
        this.duration = input.duration;
        this.id = input.id;
        this.killedBy = input.killedBy;
        this.location = input.location;
        this.mutatorName = input.mutatorName;
        this.replacement = input.replacement;
        this.static = input.static;
        this.status = input.status;
        this.statusReason = input.statusReason;
        this.testsCompleted = input.testsCompleted;
    }
    addCoveredBy(test) {
        if (!this.coveredByTests) {
            this.coveredByTests = [];
        }
        if (__classPrivateFieldGet(this, _MutantModel_coveredByTests, "f").has(test.id)) {
            return;
        }
        __classPrivateFieldGet(this, _MutantModel_coveredByTests, "f").set(test.id, test);
        this.coveredByTests?.push(test);
    }
    addKilledBy(test) {
        if (!this.killedByTests) {
            this.killedByTests = [];
        }
        if (__classPrivateFieldGet(this, _MutantModel_killedByTests, "f").has(test.id)) {
            return;
        }
        __classPrivateFieldGet(this, _MutantModel_killedByTests, "f").set(test.id, test);
        this.killedByTests?.push(test);
    }
    /**
     * Retrieves the lines of code with the mutant applied to it, to be shown in a diff view.
     */
    getMutatedLines() {
        assertSourceFileDefined(this.sourceFile);
        return this.sourceFile.getMutationLines(this);
    }
    /**
     * Retrieves the original source lines for this mutant, to be shown in a diff view.
     */
    getOriginalLines() {
        assertSourceFileDefined(this.sourceFile);
        return this.sourceFile.getLines(this.location);
    }
    /**
     * Helper property to retrieve the source file name
     * @throws When the `sourceFile` is not defined.
     */
    get fileName() {
        assertSourceFileDefined(this.sourceFile);
        return this.sourceFile.name;
    }
    // TODO: https://github.com/stryker-mutator/mutation-testing-elements/pull/2453#discussion_r1178769871
    update() {
        if (!this.sourceFile?.result?.file) {
            return;
        }
        this.sourceFile.result.updateAllMetrics();
    }
}
exports.MutantModel = MutantModel;
_MutantModel_coveredByTests = new WeakMap(), _MutantModel_killedByTests = new WeakMap();
//# sourceMappingURL=mutant-model.js.map