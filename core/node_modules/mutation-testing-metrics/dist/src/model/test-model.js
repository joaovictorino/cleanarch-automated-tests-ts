"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TestModel_killedMutants, _TestModel_coveredMutants;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestModel = exports.TestStatus = void 0;
function assertSourceFileDefined(sourceFile) {
    if (sourceFile === undefined) {
        throw new Error('test.sourceFile was not defined');
    }
}
function assertLocationDefined(location) {
    if (location === undefined) {
        throw new Error('test.location was not defined');
    }
}
var TestStatus;
(function (TestStatus) {
    TestStatus["Killing"] = "Killing";
    TestStatus["Covering"] = "Covering";
    TestStatus["NotCovering"] = "NotCovering";
})(TestStatus = exports.TestStatus || (exports.TestStatus = {}));
class TestModel {
    addCovered(mutant) {
        if (!this.coveredMutants) {
            this.coveredMutants = [];
        }
        if (__classPrivateFieldGet(this, _TestModel_coveredMutants, "f").has(mutant.id)) {
            return;
        }
        __classPrivateFieldGet(this, _TestModel_coveredMutants, "f").set(mutant.id, mutant);
        this.coveredMutants.push(mutant);
    }
    addKilled(mutant) {
        if (!this.killedMutants) {
            this.killedMutants = [];
        }
        if (__classPrivateFieldGet(this, _TestModel_killedMutants, "f").has(mutant.id)) {
            return;
        }
        __classPrivateFieldGet(this, _TestModel_killedMutants, "f").set(mutant.id, mutant);
        this.killedMutants.push(mutant);
    }
    constructor(input) {
        _TestModel_killedMutants.set(this, new Map());
        _TestModel_coveredMutants.set(this, new Map());
        Object.entries(input).forEach(([key, value]) => {
            // @ts-expect-error dynamic assignment so we won't forget to add new properties
            this[key] = value;
        });
    }
    /**
     * Retrieves the original source lines where this test is defined.
     * @throws if source file or location is not defined
     */
    getLines() {
        assertSourceFileDefined(this.sourceFile);
        assertLocationDefined(this.location);
        return this.sourceFile.getLines(this.location);
    }
    /**
     * Helper property to retrieve the source file name
     * @throws When the `sourceFile` is not defined.
     */
    get fileName() {
        assertSourceFileDefined(this.sourceFile);
        return this.sourceFile.name;
    }
    get status() {
        if (this.killedMutants?.length) {
            return TestStatus.Killing;
        }
        else if (this.coveredMutants?.length) {
            return TestStatus.Covering;
        }
        else {
            return TestStatus.NotCovering;
        }
    }
    update() {
        if (!this.sourceFile?.result?.file) {
            return;
        }
        this.sourceFile.result.updateAllMetrics();
    }
}
exports.TestModel = TestModel;
_TestModel_killedMutants = new WeakMap(), _TestModel_coveredMutants = new WeakMap();
//# sourceMappingURL=test-model.js.map