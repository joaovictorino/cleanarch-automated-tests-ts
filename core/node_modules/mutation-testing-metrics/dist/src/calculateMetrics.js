"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.countFileMetrics = exports.countTestFileMetrics = exports.calculateFileMetrics = exports.calculateMutationTestMetrics = exports.calculateMetrics = void 0;
const helpers_1 = require("./helpers");
const api_1 = require("mutation-testing-report-schema/api");
const helpers_2 = require("./helpers");
const model_1 = require("./model");
const test_model_1 = require("./model/test-model");
const DEFAULT_SCORE = NaN;
const ROOT_NAME = 'All files';
const ROOT_NAME_TESTS = 'All tests';
/**
 * Calculates the files-under-test metrics inside of a mutation testing report
 * @param files The files inside the mutation testing report
 * @returns A MetricsResult containing the metrics for the entire report. See `childResults`
 */
function calculateMetrics(files) {
    const normalizedFiles = (0, helpers_1.normalize)(files, '', (input, name) => new model_1.FileUnderTestModel(input, name));
    return calculateDirectoryMetrics(ROOT_NAME, normalizedFiles, countFileMetrics);
}
exports.calculateMetrics = calculateMetrics;
/**
 * Calculates the full mutation test metrics from both the files-under-test as well as (optionally) the test files.
 * @param result The full mutation test result
 * @returns A MutationTestMetricsResult that contains both the `systemUnderTestMetrics` as well as the `testMetrics`
 */
function calculateMutationTestMetrics(result) {
    const { files, testFiles, projectRoot = '' } = result;
    const fileModelsUnderTest = (0, helpers_1.normalize)(files, projectRoot, (input, name) => new model_1.FileUnderTestModel(input, name));
    if (testFiles && Object.keys(testFiles).length) {
        const testFileModels = (0, helpers_1.normalize)(testFiles, projectRoot, (input, name) => new model_1.TestFileModel(input, name));
        relate(Object.values(fileModelsUnderTest).flatMap((file) => file.mutants), Object.values(testFileModels).flatMap((file) => file.tests));
        return {
            systemUnderTestMetrics: calculateRootMetrics(ROOT_NAME, fileModelsUnderTest, countFileMetrics),
            testMetrics: calculateRootMetrics(ROOT_NAME_TESTS, testFileModels, countTestFileMetrics),
        };
    }
    return {
        systemUnderTestMetrics: calculateRootMetrics(ROOT_NAME, fileModelsUnderTest, countFileMetrics),
        testMetrics: undefined,
    };
}
exports.calculateMutationTestMetrics = calculateMutationTestMetrics;
function calculateRootMetrics(name, files, calculateMetrics) {
    const fileNames = Object.keys(files);
    /**
     * When a mutation testing framework doesn't report test files, but _does want to report a list of tests_,
     * it will put those tests in a 'dummy' file with an empty string as name.
     */
    if (fileNames.length === 1 && fileNames[0] === '') {
        return calculateFileMetrics(name, files[fileNames[0]], calculateMetrics);
    }
    else {
        return calculateDirectoryMetrics(name, files, calculateMetrics);
    }
}
function calculateDirectoryMetrics(name, files, calculateMetrics) {
    const metrics = calculateMetrics(Object.values(files));
    const childResults = toChildModels(files, calculateMetrics);
    return new model_1.MetricsResult(name, childResults, metrics);
}
function calculateFileMetrics(fileName, file, calculateMetrics) {
    return new model_1.MetricsResult(fileName, [], calculateMetrics([file]), file);
}
exports.calculateFileMetrics = calculateFileMetrics;
function toChildModels(files, calculateMetrics) {
    const filesByDirectory = (0, helpers_2.groupBy)(Object.entries(files), (namedFile) => namedFile[0].split('/')[0]);
    return Object.keys(filesByDirectory)
        .map((directoryName) => {
        if (filesByDirectory[directoryName].length > 1 || filesByDirectory[directoryName][0][0] !== directoryName) {
            const directoryFiles = {};
            filesByDirectory[directoryName].forEach((file) => (directoryFiles[file[0].substr(directoryName.length + 1)] = file[1]));
            return calculateDirectoryMetrics(directoryName, directoryFiles, calculateMetrics);
        }
        else {
            const [fileName, file] = filesByDirectory[directoryName][0];
            return calculateFileMetrics(fileName, file, calculateMetrics);
        }
    })
        .sort(helpers_1.compareNames);
}
function relate(mutants, tests) {
    // Create a testId -> TestModel map for fast lookup
    const testMap = new Map(tests.map((test) => [test.id, test]));
    for (const mutant of mutants) {
        const coveringTests = mutant.coveredBy?.map((testId) => testMap.get(testId)) ?? [];
        for (const test of coveringTests) {
            if (test) {
                mutant.addCoveredBy(test);
                test.addCovered(mutant);
            }
        }
        const killingTests = mutant.killedBy?.map((testId) => testMap.get(testId)) ?? [];
        for (const test of killingTests) {
            if (test) {
                mutant.addKilledBy(test);
                test.addKilled(mutant);
            }
        }
    }
}
function countTestFileMetrics(testFile) {
    const tests = testFile.flatMap((_) => _.tests);
    const count = (status) => tests.filter((_) => _.status === status).length;
    return {
        total: tests.length,
        killing: count(test_model_1.TestStatus.Killing),
        covering: count(test_model_1.TestStatus.Covering),
        notCovering: count(test_model_1.TestStatus.NotCovering),
    };
}
exports.countTestFileMetrics = countTestFileMetrics;
function countFileMetrics(fileResult) {
    const mutants = fileResult.flatMap((_) => _.mutants);
    const count = (status) => mutants.filter((_) => _.status === status).length;
    const pending = count(api_1.MutantStatus.Pending);
    const killed = count(api_1.MutantStatus.Killed);
    const timeout = count(api_1.MutantStatus.Timeout);
    const survived = count(api_1.MutantStatus.Survived);
    const noCoverage = count(api_1.MutantStatus.NoCoverage);
    const runtimeErrors = count(api_1.MutantStatus.RuntimeError);
    const compileErrors = count(api_1.MutantStatus.CompileError);
    const ignored = count(api_1.MutantStatus.Ignored);
    const totalDetected = timeout + killed;
    const totalUndetected = survived + noCoverage;
    const totalCovered = totalDetected + survived;
    const totalValid = totalUndetected + totalDetected;
    const totalInvalid = runtimeErrors + compileErrors;
    return {
        pending,
        killed,
        timeout,
        survived,
        noCoverage,
        runtimeErrors,
        compileErrors,
        ignored,
        totalDetected,
        totalUndetected,
        totalCovered,
        totalValid,
        totalInvalid,
        mutationScore: totalValid > 0 ? (totalDetected / totalValid) * 100 : DEFAULT_SCORE,
        totalMutants: totalValid + totalInvalid + ignored + pending,
        mutationScoreBasedOnCoveredCode: totalValid > 0 ? (totalDetected / totalCovered) * 100 || 0 : DEFAULT_SCORE,
    };
}
exports.countFileMetrics = countFileMetrics;
//# sourceMappingURL=calculateMetrics.js.map