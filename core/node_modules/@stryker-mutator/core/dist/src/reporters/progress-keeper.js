import { MutantStatus, PlanKind } from '@stryker-mutator/api/core';
import { Timer } from '../utils/timer.js';
export class ProgressKeeper {
    constructor() {
        this.progress = {
            survived: 0,
            timedOut: 0,
            tested: 0,
            mutants: 0,
            total: 0,
            ticks: 0,
        };
    }
    onDryRunCompleted({ timing, capabilities }) {
        this.timing = timing;
        this.capabilities = capabilities;
    }
    /**
     * An event emitted when the mutant test plan is calculated.
     * @param event The mutant test plan ready event
     */
    onMutationTestingPlanReady({ mutantPlans }) {
        this.timer = new Timer();
        this.ticksByMutantId = new Map(mutantPlans.filter(isRunPlan).map(({ netTime, mutant, runOptions }) => {
            let ticks = netTime;
            if (!this.capabilities.reloadEnvironment && runOptions.reloadEnvironment) {
                ticks += this.timing.overhead;
            }
            return [mutant.id, ticks];
        }));
        this.progress.mutants = this.ticksByMutantId.size;
        this.progress.total = [...this.ticksByMutantId.values()].reduce((acc, n) => acc + n, 0);
    }
    onMutantTested(result) {
        var _a;
        const ticks = this.ticksByMutantId.get(result.id);
        if (ticks !== undefined) {
            this.progress.tested++;
            this.progress.ticks += (_a = this.ticksByMutantId.get(result.id)) !== null && _a !== void 0 ? _a : 0;
            if (result.status === MutantStatus.Survived) {
                this.progress.survived++;
            }
            if (result.status === MutantStatus.Timeout) {
                this.progress.timedOut++;
            }
        }
        return ticks !== null && ticks !== void 0 ? ticks : 0;
    }
    getElapsedTime() {
        return this.formatTime(this.timer.elapsedSeconds());
    }
    getEtc() {
        const totalSecondsLeft = Math.floor((this.timer.elapsedSeconds() / this.progress.ticks) * (this.progress.total - this.progress.ticks));
        if (isFinite(totalSecondsLeft) && totalSecondsLeft > 0) {
            return this.formatTime(totalSecondsLeft);
        }
        else {
            return 'n/a';
        }
    }
    formatTime(timeInSeconds) {
        const hours = Math.floor(timeInSeconds / 3600);
        const minutes = Math.floor((timeInSeconds % 3600) / 60);
        return hours > 0 // conditional time formatting
            ? `~${hours}h ${minutes}m`
            : minutes > 0
                ? `~${minutes}m`
                : '<1m';
    }
}
function isRunPlan(mutantPlan) {
    return mutantPlan.plan === PlanKind.Run;
}
//# sourceMappingURL=progress-keeper.js.map